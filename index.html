<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>高度テトリス</title>
<style>
  body { background: #111; color: #fff; font-family: sans-serif; display:flex; justify-content:center; }
  canvas { background: #222; margin: 20px; }
  #info { margin-left: 20px; }
  #next, #hold { margin-bottom: 20px; }
</style>
</head>
<body>

<canvas id="game" width="240" height="480"></canvas>
<div id="info">
  <div id="score">Score: 0</div>
  <div id="level">Level: 1</div>
  <div id="next">Next:</div>
  <div id="hold">Hold:</div>
  <button id="pauseBtn">Pause</button>
  <button id="holdBtn">Hold</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ROWS = 20, COLS = 10, BLOCK = 24;
let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));

const colors = [
  null,
  'cyan',    // I
  'blue',    // J
  'orange',  // L
  'yellow',  // O
  'green',   // S
  'purple',  // T
  'red'      // Z
];

const pieces = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[2,0,0],[2,2,2],[0,0,0]],
  L: [[0,0,3],[3,3,3],[0,0,0]],
  O: [[4,4],[4,4]],
  S: [[0,5,5],[5,5,0],[0,0,0]],
  T: [[0,6,0],[6,6,6],[0,0,0]],
  Z: [[7,7,0],[0,7,7],[0,0,0]]
};

let current, next, holdPiece = null, canHold = true;
let score = 0, level = 1, linesCleared = 0;
let dropInterval = 1000, lastDrop = 0;
let paused = false;

// --- 7種一巡法則 ---
let bag = [];
function getNextPiece() {
  if(bag.length === 0){
    bag = Object.keys(pieces).sort(()=>Math.random()-0.5);
  }
  return bag.pop();
}

// --- テトリス操作 ---
function rotate(matrix, dir) {
  for(let y=0;y<matrix.length;y++){
    for(let x=y+1;x<matrix[y].length;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}

function collide(board, piece, offset) {
  for(let y=0;y<piece.length;y++){
    for(let x=0;x<piece[y].length;x++){
      if(piece[y][x] && (board[y+offset.y] && board[y+offset.y][x+offset.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(board, piece, offset){
  for(let y=0;y<piece.length;y++){
    for(let x=0;x<piece[y].length;x++){
      if(piece[y][x]) board[y+offset.y][x+offset.x] = piece[y][x];
    }
  }
}

function lineClear(){
  let count = 0;
  outer: for(let y=ROWS-1;y>=0;y--){
    if(board[y].every(v=>v!==0)){
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      count++;
      y++;
    }
  }
  // スコア計算
  if(count>0){
    const totalBlocks = board.flat().filter(v=>v!==0).length;
    let add = 0;
    if(count===1) add = (totalBlocks===ROWS*COLS)?900:100;
    else if(count===2) add = (totalBlocks===ROWS*COLS)?1500:300;
    else if(count===3) add = (totalBlocks===ROWS*COLS)?2300:500;
    else if(count===4) add = (totalBlocks===ROWS*COLS)?2800:800;
    score += add;
    linesCleared += count;
    level = Math.floor(linesCleared/10)+1;
    dropInterval = Math.max(1000-50*(level-1), 100);
    document.getElementById('score').innerText = 'Score: '+score;
    document.getElementById('level').innerText = 'Level: '+level;
  }
}

// --- ホールド ---
function hold(){
  if(!canHold) return;
  if(holdPiece){
    [current.type, holdPiece] = [holdPiece, current.type];
    current.matrix = pieces[current.type];
    current.pos = {x:3, y:0};
  } else {
    holdPiece = current.type;
    current = {type:getNextPiece(), matrix:null, pos:{x:3,y:0}};
    current.matrix = pieces[current.type];
  }
  canHold = false;
  updateHoldDisplay();
}

function updateHoldDisplay(){
  document.getElementById('hold').innerText = 'Hold: ' + (holdPiece || 'None');
}

function nextPieceSetup(){
  next = getNextPiece();
  document.getElementById('next').innerText = 'Next: ' + next;
}

// --- ゴースト ---
function drawGhost(){
  let ghostY = current.pos.y;
  while(!collide(board, current.matrix, {x:current.pos.x,y:ghostY+1})) ghostY++;
  drawMatrix(current.matrix, current.pos.x, ghostY, 'rgba(255,255,255,0.3)');
}

// --- 描画 ---
function drawMatrix(matrix, offsetX, offsetY, colorOverride=null){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<matrix[y].length;x++){
      if(matrix[y][x]){
        ctx.fillStyle = colorOverride || colors[matrix[y][x]];
        ctx.fillRect((x+offsetX)*BLOCK, (y+offsetY)*BLOCK, BLOCK-1, BLOCK-1);
      }
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMatrix(board,0,0);
  drawGhost();
  drawMatrix(current.matrix, current.pos.x, current.pos.y);
}

// --- 移動 ---
function move(dir){
  current.pos.x += dir;
  if(collide(board, current.matrix, current.pos)) current.pos.x -= dir;
}

function rotateCurrent(dir){
  rotate(current.matrix, dir);
  if(collide(board, current.matrix, current.pos)){
    rotate(current.matrix, -dir);
  }
}

function drop(){
  current.pos.y++;
  if(collide(board, current.matrix, current.pos)){
    current.pos.y--;
    merge(board, current.matrix, current.pos);
    lineClear();
    current = {type:next, matrix:pieces[next], pos:{x:3,y:0}};
    nextPieceSetup();
    canHold = true;
    if(collide(board, current.matrix, current.pos)){
      alert('Game Over');
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      score = 0;
      linesCleared = 0;
      level = 1;
      document.getElementById('score').innerText = 'Score: 0';
      document.getElementById('level').innerText = 'Level: 1';
    }
  }
}

// --- キー操作 ---
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') move(-1);
  else if(e.key==='ArrowRight') move(1);
  else if(e.key==='ArrowUp') rotateCurrent(1);
  else if(e.key==='ArrowDown') rotateCurrent(-1);
  else if(e.key===' ') drop();
  else if(e.key==='p') paused = !paused;
  else if(e.key==='c') hold();
});

// --- モバイルスワイプ ---
let touchStartX=0, touchStartY=0;
canvas.addEventListener('touchstart', e=>{
  let t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
});
canvas.addEventListener('touchend', e=>{
  let t = e.changedTouches[0];
  let dx = t.clientX - touchStartX;
  let dy = t.clientY - touchStartY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>0) move(1); else move(-1);
  } else {
    if(dy>0) rotateCurrent(-1); else rotateCurrent(1);
  }
});

// --- ボタン ---
document.getElementById('pauseBtn').addEventListener('click', ()=> paused = !paused);
document.getElementById('holdBtn').addEventListener('click', hold);

// --- 初期化 ---
current = {type:getNextPiece(), matrix:null, pos:{x:3,y:0}};
current.matrix = pieces[current.type];
nextPieceSetup();
updateHoldDisplay();

// --- ゲームループ ---
let lastTime = 0;
function update(time=0){
  const delta = time - lastTime;
  lastTime = time;
  if(!paused){
    lastDrop += delta;
    if(lastDrop>dropInterval){
      drop();
      lastDrop = 0;
    }
    draw();
  }
  requestAnimationFrame(update);
}
update();
</script>

</body>
</html>
