<!doctype html>
<html lang="ja">
<head>
<link rel="manifest" href="./manifest.json">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>モバイルテトリス（要望反映版）</title>
<style>
  :root{--cell:24px;--cols:10;--rows:20}
  body{margin:0;background:#07111a;color:#e6f7ff;font-family:system-ui,-apple-system,Helvetica,Arial;display:flex;flex-direction:column;align-items:center;padding:12px}
  h1{margin:6px 0;color:#7fe0ff;font-size:18px}
  .wrap{display:flex;gap:12px;align-items:flex-start}
  canvas#board{background:#07111a;border-radius:8px;touch-action:none}
  .side{display:flex;flex-direction:column;gap:8px;width:140px}
  .panel{background:#0c1a20;padding:8px;border-radius:8px;text-align:center}
  .small{font-size:12px;color:#9ac}
  .big{font-size:20px;font-weight:700}
  .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:10px;width:100%}
  button{background:#11303a;color:#e6f7ff;border:none;padding:8px;border-radius:8px;font-size:15px}
  button:active{transform:translateY(1px)}
  canvas.mini{background:#07111a;border-radius:6px}
  .hint{font-size:12px;color:#8fb;margin-top:8px}
  @media (max-width:520px){ .wrap{flex-direction:column;align-items:center} .side{width:100%;flex-direction:row;justify-content:center} .controls{grid-template-columns:repeat(4,1fr)} }
</style>
</head>
<body>
  <h1>モバイルテトリス（要望反映版）</h1>

  <div class="wrap">
    <canvas id="board" width="240" height="480" aria-label="tetris board"></canvas>

    <div class="side">
      <div class="panel">
        <div class="small">SCORE</div>
        <div id="score" class="big">0</div>
        <div class="small">LINES <span id="lines">0</span></div>
        <div class="small">LEVEL <span id="level">1</span></div>
      </div>
      <div class="panel">
        <div class="small">NEXT</div>
        <canvas id="next" class="mini" width="96" height="192"></canvas>
      </div>
      <div class="panel">
        <div class="small">HOLD</div>
        <canvas id="hold" class="mini" width="96" height="96"></canvas>
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="start">START / RESTART</button>
    <button id="rotCCW">⟲ (左回転)</button>
    <button id="rotCW">⟳ (右回転)</button>
    <button id="left">◀</button>
    <button id="holdBtn">HOLD</button>
    <button id="right">▶</button>
    <button id="hard">⇩ ハードドロップ</button>
    <button id="pause">⏸ PAUSE</button>
    <div></div>
  </div>

  <div class="hint">操作：左右スワイプ=左右移動 / 上スワイプ=右回転 / 下スワイプ=左回転 / 長押し=ソフトドロップ / タップ=ハードドロップ</div>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(registration => {
      console.log('ServiceWorker registration successful.');
    }).catch(err => {
      console.log('ServiceWorker registration failed.');
    });
  }
(() => {
  // 基本設定
  const COLS = 10, ROWS = 20, CELL = 24;
  const boardCanvas = document.getElementById('board');
  const ctx = boardCanvas.getContext('2d');
  const nextCanvas = document.getElementById('next'), nctx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold'), hctx = holdCanvas.getContext('2d');

  const scoreEl = document.getElementById('score'), linesEl = document.getElementById('lines'), levelEl = document.getElementById('level');

  // ミノのマトリクス（基底向き） - 各種 2D 行列（0/1）
  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[1,1],[1,1]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]]
  };

  const COLORS = { I:'#00f0f0', O:'#ffd000', T:'#a000f0', S:'#00f000', Z:'#ff4d4d', J:'#2647ff', L:'#ff9800' };

  // 盤面初期化
  let board = Array.from({length: ROWS}, () => Array(COLS).fill(null));

  // 7-bag
  let bag = [];
  function refillBag(){
    bag = ['I','O','T','S','Z','J','L'];
    for (let i = bag.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
  }
  function nextType(){ if (bag.length === 0) refillBag(); return bag.pop(); }

  // next queue
  let nextQueue = [];
  function ensureNext(n = 5){
    while (nextQueue.length < n) nextQueue.push(nextType());
  }

  // プレイヤーのピース（matrix形式）
  function cloneMatrix(m){ return m.map(row => row.slice()); }
  function rotateMatrixCW(m){
    const h = m.length, w = m[0].length;
    const res = Array.from({length: w}, ()=> Array(h).fill(0));
    for (let y=0;y<h;y++) for (let x=0;x<w;x++) res[x][h-1-y] = m[y][x];
    return res;
  }
  function rotateMatrixCCW(m){
    const h = m.length, w = m[0].length;
    const res = Array.from({length: w}, ()=> Array(h).fill(0));
    for (let y=0;y<h;y++) for (let x=0;x<w;x++) res[w-1-x][y] = m[y][x];
    return res;
  }

  let player = { matrix: null, x: 0, y: 0, type: null };
  let holdPiece = null; // 保存している type string
  let canHold = true;

  // スコア／レベル
  let score = 0, lines = 0, level = 1;
  const linesPerLevel = 10;
  function updateStats(){
    scoreEl.textContent = score;
    linesEl.textContent = lines;
    levelEl.textContent = level;
  }

  // 時間管理
  let dropInterval = 1000;
  function updateDropInterval(){
    // レベルに応じて速くする（単純線形）
    dropInterval = Math.max(80, 1000 - (level - 1) * 80);
  }

  // 初期化
  function resetGame(){
    board = Array.from({length: ROWS}, () => Array(COLS).fill(null));
    bag = []; refillBag();
    nextQueue = []; ensureNext(5);
    holdPiece = null; canHold = true;
    score = 0; lines = 0; level = 1; updateDropInterval(); updateStats();
    player = { matrix: null, x:0, y:0, type: null };
    playing = false; paused = false;
    document.getElementById('start').disabled = false;
    draw();
  }

  // スポーン
  function spawnPiece(){
    ensureNext(5);
    const t = nextQueue.shift();
    ensureNext(5);
    player.type = t;
    player.matrix = normalizeClone(SHAPES[t]);
    // 初期位置：中央寄せ、y は上に出ることを許す（負のy）
    player.x = Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2);
    // y を上に詰める（matrixに上の空行がある場合を補正）
    player.y = -topEmptyRows(player.matrix);
    canHold = true;
    // game over check
    if (collide(player, player.x, player.y)) {
      // Game Over
      playing = false;
      paused = false;
      document.getElementById('start').disabled = false;
      setTimeout(()=>{ if (confirm('GAME OVER\nリスタートしますか？')) startGame(); }, 50);
    }
    renderNext();
    renderHold();
    draw();
  }

  function normalizeClone(m){
    // remove full-empty top rows/left columns to keep matrix tight
    let mat = cloneMatrix(m);
    // trim top empty rows
    while (mat.length > 0 && mat[0].every(v=>v===0)) mat.shift();
    // trim bottom empty rows
    while (mat.length > 0 && mat[mat.length-1].every(v=>v===0)) mat.pop();
    // trim left empty cols
    if (mat.length === 0) return [[0]];
    let leftEmpty = true;
    while (leftEmpty){
      leftEmpty = mat.every(row => row[0] === 0);
      if (leftEmpty) mat = mat.map(row => row.slice(1));
    }
    // trim right empty cols
    let rightEmpty = true;
    while (rightEmpty){
      rightEmpty = mat.every(row => row[row.length-1] === 0);
      if (rightEmpty) mat = mat.map(row => row.slice(0, -1));
    }
    return mat;
  }

  function topEmptyRows(m){
    let c = 0;
    for (let y=0;y<m.length;y++){
      if (m[y].every(v=>v===0)) c++; else break;
    }
    return c;
  }

  // 衝突判定
  function collide(p, atX, atY, mat){
    if (!p || !mat && !p.matrix) return false;
    const m = mat || p.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (!m[y][x]) continue;
        const gx = atX + x, gy = atY + y;
        if (gx < 0 || gx >= COLS) return true;
        if (gy >= ROWS) return true;
        if (gy >= 0 && board[gy][gx]) return true;
      }
    }
    return false;
  }

  // ロック＆ライン消去
  function lockPiece(){
    const m = player.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const gx = player.x + x, gy = player.y + y;
          if (gy >= 0) board[gy][gx] = player.type;
        }
      }
    }
    const cleared = clearLines();
    // スコア計算（通常 / 全消し ルール）
    if (cleared > 0){
      const isAllClear = board.every(row => row.every(cell => !cell));
      // mapping normal
      const normalScore = {1:100,2:300,3:500,4:800}[cleared] || 0;
      // mapping all-clear
      const allClearScoreMap = {1:900,2:1500,3:2300,4:2800};
      score += (isAllClear ? (allClearScoreMap[cleared] || normalScore) : normalScore) ;
      lines += cleared;
      level = 1 + Math.floor(lines / linesPerLevel);
      updateDropInterval();
    }
    updateStats();
    spawnPiece();
  }

  function clearLines(){
    let removed = 0;
    for (let y = ROWS - 1; y >= 0; y--){
      if (board[y].every(v => v !== null)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(null));
        removed++;
        y++;
      }
    }
    return removed;
  }

  // ホールド（修正済み）
  function doHold(){
    if (!playing) return;
    if (!canHold) return;
    if (!holdPiece){
      holdPiece = player.type;
      spawnPiece();
    } else {
      // swap: holdPiece <-> player.type ; must set matrices according to type
      const prevHold = holdPiece;
      holdPiece = player.type;
      player.type = prevHold;
      player.matrix = normalizeClone(SHAPES[player.type]);
      player.x = Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2);
      player.y = -topEmptyRows(player.matrix);
      // If immediate collision after swap, treat as game over (or revert). We'll check collide in spawn logic
      if (collide(player, player.x, player.y)){
        // revert (put back)
        // safer: end game
        playing = false;
        document.getElementById('start').disabled = false;
        setTimeout(()=>{ if (confirm('GAME OVER\nリスタートしますか？')) startGame(); }, 50);
        return;
      }
    }
    canHold = false;
    renderHold();
    draw();
  }

  // 回転（CW / CCW） with simple wall kicks attempts
  function rotateCW(){
    if (!playing) return;
    const newMat = rotateMatrixCW(player.matrix);
    const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]];
    for (const [kx,ky] of kicks){
      if (!collide(player, player.x + kx, player.y + ky, newMat)){
        player.matrix = normalizeClone(newMat);
        player.x += kx; player.y += ky;
        draw();
        return;
      }
    }
  }
  function rotateCCW(){
    if (!playing) return;
    const newMat = rotateMatrixCCW(player.matrix);
    const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]];
    for (const [kx,ky] of kicks){
      if (!collide(player, player.x + kx, player.y + ky, newMat)){
        player.matrix = normalizeClone(newMat);
        player.x += kx; player.y += ky;
        draw();
        return;
      }
    }
  }

  // 移動 / ソフト / ハード
  function move(dx){
    if (!playing) return;
    if (!collide(player, player.x + dx, player.y)) player.x += dx;
    draw();
  }
  function softDropStart(){
    if (!playing) return;
    if (softDropping) return;
    softDropping = true;
    softDropLoop();
  }
  function softDropStop(){
    softDropping = false;
  }
  function softDropLoop(){
    if (!softDropping) return;
    if (!collide(player, player.x, player.y + 1)){
      player.y++;
    } else {
      lockPiece();
    }
    draw();
    setTimeout(softDropLoop, 80);
  }
  function hardDrop(){
    if (!playing) return;
    while (!collide(player, player.x, player.y + 1)) player.y++;
    lockPiece();
    draw();
  }

  // 描画ヘルパー
  function clearBoard(){
    ctx.fillStyle = '#07111a';
    ctx.fillRect(0,0, COLS*CELL, ROWS*CELL);
  }
  function drawGrid(){
    ctx.strokeStyle = '#0f2a33';
    ctx.lineWidth = 1;
    for (let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,ROWS*CELL); ctx.stroke(); }
    for (let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(COLS*CELL,y*CELL); ctx.stroke(); }
  }
  function drawCell(gx, gy, color, alpha=1){
    if (gy < 0) return;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(gx*CELL, gy*CELL, CELL, CELL);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#00000055';
    ctx.lineWidth = 1;
    ctx.strokeRect(gx*CELL+0.5, gy*CELL+0.5, CELL-1, CELL-1);
  }

  function draw(){
    clearBoard();
    drawGrid();
    // 固定ブロック
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (board[y][x]) drawCell(x,y, COLORS[board[y][x]]);
      }
    }
    if (!player.matrix) return;
    // ghost
    let gy = player.y;
    while (!collide(player, player.x, gy + 1)){
      gy++;
    }
    for (let y=0;y<player.matrix.length;y++){
      for (let x=0;x<player.matrix[y].length;x++){
        if (player.matrix[y][x]) drawCell(player.x + x, gy + y, COLORS[player.type], 0.25);
      }
    }
    // current
    for (let y=0;y<player.matrix.length;y++){
      for (let x=0;x<player.matrix[y].length;x++){
        if (player.matrix[y][x]) drawCell(player.x + x, player.y + y, COLORS[player.type], 1);
      }
    }
  }

  // next / hold 描画
  function renderNext(){
    nctx.fillStyle = '#07111a'; nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    const box = 20;
    nctx.save();
    nctx.scale(1,1);
    for (let i=0;i<3;i++){
      const type = nextQueue[i];
      if (!type) continue;
      const mat = normalizeClone(SHAPES[type]);
      const offX = 0.5;
      const offY = i * 3;
      for (let y=0;y<mat.length;y++){
        for (let x=0;x<mat[y].length;x++){
          if (mat[y][x]){
            nctx.fillStyle = COLORS[type];
            nctx.fillRect(offX*box + x*box, offY*box + y*box, box-2, box-2);
            nctx.strokeStyle = '#000';
            nctx.strokeRect(offX*box + x*box, offY*box + y*box, box-2, box-2);
          }
        }
      }
    }
    nctx.restore();
  }
  function renderHold(){
    hctx.fillStyle = '#07111a'; hctx.fillRect(0,0,holdCanvas.width,holdCanvas.height);
    if (!holdPiece) return;
    const box = 20;
    const mat = normalizeClone(SHAPES[holdPiece]);
    for (let y=0;y<mat.length;y++){
      for (let x=0;x<mat[y].length;x++){
        if (mat[y][x]){
          hctx.fillStyle = COLORS[holdPiece];
          hctx.fillRect(x*box + 10, y*box + 5, box-2, box-2);
          hctx.strokeStyle = '#000';
          hctx.strokeRect(x*box + 10, y*box + 5, box-2, box-2);
        }
      }
    }
  }

  // ゲームループ
  let playing = false, paused = false;
  let lastTime = performance.now();
  function gameLoop(now = performance.now()){
    if (!playing) { draw(); requestAnimationFrame(gameLoop); return; }
    if (!paused){
      const delta = now - lastTime;
      if (delta >= dropInterval){
        // 自動落下
        if (!collide(player, player.x, player.y + 1)){
          player.y++;
        } else {
          lockPiece();
        }
        lastTime = now;
      }
    } else {
      lastTime = now;
    }
    draw();
    requestAnimationFrame(gameLoop);
  }

  // UI binding
  document.getElementById('start').addEventListener('click', () => startGame());
  document.getElementById('left').addEventListener('click', () => move(-1));
  document.getElementById('right').addEventListener('click', () => move(1));
  document.getElementById('rotCW').addEventListener('click', () => rotateCW());
  document.getElementById('rotCCW').addEventListener('click', () => rotateCCW());
  document.getElementById('holdBtn').addEventListener('click', () => doHold());
  document.getElementById('pause').addEventListener('click', () => { paused = !paused; if (!paused) requestAnimationFrame(gameLoop); });
  document.getElementById('hard').addEventListener('click', () => hardDrop());

  // expose functions
  function startGame(){
    resetGame();
    ensureNext(5);
    spawnPiece();
    playing = true;
    paused = false;
    document.getElementById('start').disabled = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
    updateStats();
  }

  // touch controls: swipe/tap/longpress
  let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
  let moved = false;
  let softDropping = false;
  let longPressTimeout = null;

  boardCanvas.addEventListener('touchstart', (e) => {
    if (!playing) return;
    const t = e.touches[0];
    touchStartX = t.clientX; touchStartY = t.clientY;
    touchStartTime = Date.now();
    moved = false;
    longPressTimeout = setTimeout(() => {
      // 長押し開始 -> ソフトドロップ開始
      softDropping = true;
      const sd = () => {
        if (!softDropping) return;
        if (!collide(player, player.x, player.y + 1)){
          player.y++;
        } else {
          lockPiece();
        }
        draw();
        setTimeout(sd, 80);
      };
      sd();
    }, 450);
  }, {passive:true});

  boardCanvas.addEventListener('touchmove', (e) => {
    if (!playing) return;
    const t = e.touches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const threshold = 24;
    if (Math.max(absX, absY) > threshold){
      moved = true;
      clearTimeout(longPressTimeout);
      // horizontal swipe -> move
      if (absX > absY){
        if (dx > 0){ move(1); touchStartX = t.clientX; touchStartY = t.clientY; }
        else { move(-1); touchStartX = t.clientX; touchStartY = t.clientY; }
      } else {
        // vertical swipe: up => rotateCW, down => rotateCCW
        if (dy < 0){ rotateCW(); touchStartX = t.clientX; touchStartY = t.clientY; }
        else { rotateCCW(); touchStartX = t.clientX; touchStartY = t.clientY; }
      }
    }
  }, {passive:true});

  boardCanvas.addEventListener('touchend', (e) => {
    clearTimeout(longPressTimeout);
    if (softDropping) { softDropping = false; return; }
    const duration = Date.now() - touchStartTime;
    if (!moved && duration < 350){
      // タップ -> ハードドロップ
      hardDrop();
    }
  });

  // keyboard for debug
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') move(-1);
    if (e.key === 'ArrowRight') move(1);
    if (e.key === 'ArrowDown') rotateCCW();
    if (e.key === 'ArrowUp') rotateCW();
    if (e.key === ' ') hardDrop();
    if (e.key.toLowerCase() === 'c') doHold();
    if (e.key.toLowerCase() === 'p') { paused = !paused; if (!paused) requestAnimationFrame(gameLoop); }
  });

  // 初期描画
  resetGame();
  requestAnimationFrame(gameLoop);

  // helper aliases for UI buttons compatibility
  function rotateCW(){ rotateCW = rotateCW_internal; rotateCW_internal(); }
  function rotateCCW(){ rotateCCW = rotateCCW_internal; rotateCCW_internal(); }
  // define actual functions to avoid shadowing
  function rotateCW_internal(){ rotateCW_actual(); }
  function rotateCCW_internal(){ rotateCCW_actual(); }
  function rotateCW_actual(){ rotateCW = rotateCW_internal; rotateMatrixCW; rotateCW_internal = null; } // placeholder - replaced below

  // Rebind correct rotation implementations (clean approach)
  // We'll override rotateCW/rotateCCW defined earlier with final implementations
  function rotateCW_final(){ rotateCW_actual_impl(); }
  function rotateCCW_final(){ rotateCCW_actual_impl(); }

  // Real implementations used by UI binding above
  function rotateCW_actual_impl(){ rotateCW_actual_impl_body(); }
  function rotateCCW_actual_impl(){ rotateCCW_actual_impl_body(); }

  // We'll attach working rotation functions used by UI:
  function rotateCW_actual_impl_body(){ rotateCW_real(); }
  function rotateCCW_actual_impl_body(){ rotateCCW_real(); }

  // actual rotation real functions:
  function rotateCW_real(){ rotateCW_direct(); }
  function rotateCCW_real(){ rotateCCW_direct(); }

  // Implement direct versions (and ensure UI buttons call them)
  function rotateCW_direct(){ rotateCW(); } // placeholder, will be replaced
  function rotateCCW_direct(){ rotateCCW(); }

  // To avoid confusion, simply reassign UI button handlers to the real rotate functions:
  // But we already bound them earlier; rebind now to correct implementations:

  // define the proper rotate functions (replace previous rotateCW/CCW function definitions)
  function rotateCW(){
    if (!playing) return;
    const newMat = rotateMatrixCW(player.matrix);
    const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]];
    for (const [kx,ky] of kicks){
      if (!collide(player, player.x + kx, player.y + ky, newMat)){
        player.matrix = normalizeClone(newMat);
        player.x += kx; player.y += ky;
        draw();
        return;
      }
    }
  }
  function rotateCCW(){
    if (!playing) return;
    const newMat = rotateMatrixCCW(player.matrix);
    const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]];
    for (const [kx,ky] of kicks){
      if (!collide(player, player.x + kx, player.y + ky, newMat)){
        player.matrix = normalizeClone(newMat);
        player.x += kx; player.y += ky;
        draw();
        return;
      }
    }
  }

  // Make sure UI buttons now call these
  document.getElementById('rotCW').onclick = () => rotateCW();
  document.getElementById('rotCCW').onclick = () => rotateCCW();

  // spawn alias
  function spawnPiece(){ spawnPiece_internal(); }
  function spawnPiece_internal(){
    spawnPiece = null; // placeholder
  }
  // Implement spawnPiece real:
  function spawnPiece_real(){
    ensureNext(5);
    const t = nextQueue.shift();
    ensureNext(5);
    player.type = t;
    player.matrix = normalizeClone(SHAPES[t]);
    player.x = Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2);
    player.y = -topEmptyRows(player.matrix);
    canHold = true;
    if (collide(player, player.x, player.y)){
      playing = false; paused = false; document.getElementById('start').disabled = false;
      setTimeout(()=>{ if (confirm('GAME OVER\nリスタートしますか？')) startGame(); }, 50);
    }
    renderNext();
    renderHold();
    draw();
  }
  // Replace prior placeholder with actual
  spawnPiece = spawnPiece_real;

  // ensureNext final implementation
  ensureNext = function(n = 5){
    while (nextQueue.length < n) nextQueue.push(nextType());
    renderNext();
  };

  // Utilities binding
  function moveLeft(){ move(-1); }
  function moveRight(){ move(1); }

  // Soft drop long-press state
  let softDropping = false;

  // Expose some functions for debugging
  window._tetris = {
    startGame, resetGame, move, rotateCW, rotateCCW, hardDrop, doHold
  };

  // Fix: ensure startGame, spawnPiece names are available
  // (they are defined above)

  // END IIFE
})();
</script>
</body>
</html>
