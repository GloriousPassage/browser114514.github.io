<!DOCTYPE html>
<html lang="ja">
<head>
<link rel="manifest" href="./manifest.json">
<meta charset="UTF-8">
<title>テトリス</title>
<style>
  body { background:#111; color:white; font-family:sans-serif; text-align:center; margin:0; }
  canvas { background:#000; display:block; margin:10px auto; }
  #ui { display:flex; justify-content:space-around; margin-top:5px; }
  .panel { text-align:left; }
</style>
</head>
<body>
<h2>テトリス</h2>
<canvas id="board" width="300" height="600"></canvas>
<div id="ui">
  <div class="panel">
    <p>スコア: <span id="score">0</span></p>
    <p>レベル: <span id="level">1</span></p>
  </div>
  <div class="panel">
    <p>Next:</p>
    <canvas id="next" width="100" height="100"></canvas>
  </div>
  <div class="panel">
    <p>Hold:</p>
    <canvas id="hold" width="100" height="100"></canvas>
  </div>
</div>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(registration => {
      console.log('ServiceWorker registration successful.');
    }).catch(err => {
      console.log('ServiceWorker registration failed.');
    });
  }
const COLS=10, ROWS=20, BLOCK=30;
const canvas=document.getElementById("board"), ctx=canvas.getContext("2d");
const nextCanvas=document.getElementById("next"), nctx=nextCanvas.getContext("2d");
const holdCanvas=document.getElementById("hold"), hctx=holdCanvas.getContext("2d");

const colors=["cyan","blue","orange","yellow","green","purple","red"];
const shapes=[
  [[1,1,1,1]], // I
  [[2,0,0],[2,2,2]], // J
  [[0,0,3],[3,3,3]], // L
  [[4,4],[4,4]],     // O
  [[0,5,5],[5,5,0]], // S
  [[0,6,0],[6,6,6]], // T
  [[7,7,0],[0,7,7]]  // Z
];

let board, currentPiece, nextQueue=[], holdPiece=null, holdUsed=false;
let score=0, level=1, lines=0;
let dropStart=Date.now(), dropInterval=1000;

// 7種一巡
function generateBag(){
  let bag=[0,1,2,3,4,5,6];
  for(let i=bag.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [bag[i],bag[j]]=[bag[j],bag[i]];
  }
  nextQueue.push(...bag);
}
function Piece(type){
  this.type=type;
  this.shape=shapes[type].map(r=>[...r]);
  this.x=3;
  this.y=0;
}
function newPiece(){
  if(nextQueue.length<7) generateBag();
  return new Piece(nextQueue.shift());
}
function resetBoard(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(0));
}
function drawBlock(ctx,x,y,val){
  ctx.fillStyle=colors[val-1];
  ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
  ctx.strokeStyle="#111";
  ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
}
function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(board[y][x]) drawBlock(ctx,x,y,board[y][x]);
    }
  }
  drawPiece(currentPiece,ctx);
  drawGhost();
}
function drawPiece(p,context){
  for(let y=0;y<p.shape.length;y++){
    for(let x=0;x<p.shape[y].length;x++){
      if(p.shape[y][x]) drawBlock(context,p.x+x,p.y+y,p.shape[y][x]);
    }
  }
}
function drawGhost(){
  let ghost=JSON.parse(JSON.stringify(currentPiece));
  while(!collide(ghost)) ghost.y++;
  ghost.y--;
  for(let y=0;y<ghost.shape.length;y++){
    for(let x=0;x<ghost.shape[y].length;x++){
      if(ghost.shape[y][x]){
        ctx.globalAlpha=0.3;
        drawBlock(ctx,ghost.x+x,ghost.y+y,ghost.shape[y][x]);
        ctx.globalAlpha=1.0;
      }
    }
  }
}
function collide(p){
  for(let y=0;y<p.shape.length;y++){
    for(let x=0;x<p.shape[y].length;x++){
      if(p.shape[y][x]){
        let nx=p.x+x, ny=p.y+y;
        if(nx<0||nx>=COLS||ny>=ROWS) return true;
        if(ny>=0&&board[ny][nx]) return true;
      }
    }
  }
  return false;
}
function merge(p){
  for(let y=0;y<p.shape.length;y++){
    for(let x=0;x<p.shape[y].length;x++){
      if(p.shape[y][x]){
        board[p.y+y][p.x+x]=p.shape[y][x];
      }
    }
  }
}
function clearLines(){
  let cleared=0;
  outer: for(let y=ROWS-1;y>=0;y--){
    if(board[y].every(v=>v>0)){
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      cleared++;
      y++;
    }
  }
  if(cleared>0){
    lines+=cleared;
    let add=0;
    const allClear=board.every(row=>row.every(v=>v===0));
    if(cleared===1) add=allClear?900:100;
    if(cleared===2) add=allClear?1500:300;
    if(cleared===3) add=allClear?2300:500;
    if(cleared===4) add=allClear?2800:800;
    score+=add;
    if(lines>=level*10){ level++; dropInterval=Math.max(100,dropInterval-100);}
  }
}
function rotate(p,dir){
  const N=p.shape.length;
  let m=p.shape.map((r,i)=>r.map((_,j)=>p.shape[N-1-j][i]));
  if(dir<0) m=m.map((r,i)=>r.map((_,j)=>p.shape[j][N-1-i]));
  let test=new Piece(p.type);
  test.shape=m; test.x=p.x; test.y=p.y;
  if(!collide(test)) p.shape=m;
}
function hold(){
  if(holdUsed) return;
  if(!holdPiece){
    holdPiece=new Piece(currentPiece.type);
    currentPiece=newPiece();
  }else{
    let tmp=new Piece(currentPiece.type);
    currentPiece=new Piece(holdPiece.type);
    holdPiece=tmp;
  }
  currentPiece.x=3; currentPiece.y=0;
  holdUsed=true;
}
function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  let next=new Piece(nextQueue[0]);
  next.x=1; next.y=1;
  drawPiece(next,nctx);
}
function drawHold(){
  hctx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
  if(holdPiece){
    let hp=new Piece(holdPiece.type);
    hp.x=1; hp.y=1;
    drawPiece(hp,hctx);
  }
}
function drop(){
  currentPiece.y++;
  if(collide(currentPiece)){
    currentPiece.y--;
    merge(currentPiece);
    clearLines();
    currentPiece=newPiece();
    holdUsed=false;
    if(collide(currentPiece)){ resetBoard(); score=0; level=1; lines=0; }
  }
  dropStart=Date.now();
}
function update(){
  if(Date.now()-dropStart>dropInterval) drop();
  drawBoard();
  drawNext();
  drawHold();
  document.getElementById("score").innerText=score;
  document.getElementById("level").innerText=level;
  requestAnimationFrame(update);
}
resetBoard(); generateBag(); currentPiece=newPiece(); update();

// タッチ操作
let startX,startY,startTime;
canvas.addEventListener("touchstart",e=>{
  startX=e.touches[0].clientX;
  startY=e.touches[0].clientY;
  startTime=Date.now();
});
canvas.addEventListener("touchend",e=>{
  let dx=e.changedTouches[0].clientX-startX;
  let dy=e.changedTouches[0].clientY-startY;
  let dt=Date.now()-startTime;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>30) currentPiece.x++;
    else if(dx<-30) currentPiece.x--;
    if(collide(currentPiece)) currentPiece.x-=Math.sign(dx);
  }else{
    if(dy<-30) rotate(currentPiece,1); // 上スワイプ右回転
    else if(dy>30) rotate(currentPiece,-1); // 下スワイプ左回転
  }
  if(dt>500){ currentPiece.y++; drop(); } // 長押しソフトドロップ
  else if(Math.abs(dx)<10&&Math.abs(dy)<10){ // タップ → ハードドロップ
    while(!collide(currentPiece)) currentPiece.y++;
    currentPiece.y--;
    merge(currentPiece);
    clearLines();
    currentPiece=newPiece();
    holdUsed=false;
  }
});
</script>
</body>
</html>
